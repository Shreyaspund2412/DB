Hastebin
/* 1.	Create following tables with primary and foreign key and solve the queries given below
Person (driver_id, name, address)
Car (license, model, year)
Accident (report_no, date_acc, location)
Owns (driver_id, license)
Participated (driver_id,  model,  report_no, damage_amount)
1.	Insert records into each table
2.	Create a view named Driver_Car_View to show each driver‚Äôs name and the car model they own.
3.	Display all records from the Driver_Car_View.
4.	Modify the existing view Driver_Car_View to include the car‚Äôs year of manufacture.
5.	Create a sequence named seq_report_no starting from 6001 and increment by 5 for new accidents.
6.	Create a composite index on model and year columns of the Car table.
a.	Create a view to show all drivers who participated in accidents with damage amount greater than ‚Çπ20,000.
7.	Create a sequence named seq_driver_id to auto-generate driver IDs starting from 201 and increment by 1.
8.	Insert a new record into Person using the Sequence.
9.	Create an index on the name column of the Person table for faster searching.
10.	Drop the index created on name column of Person.
11.	Create a view named Recent_Accidents that shows accidents that occurred in the year 2025.
12.	Drop the view Recent_Accidents.
13.	Create a synonym named acc_info for the Accident table.
14.	Insert a new accident record using the acc_info synonym.
15.	Create a unique index on license column of the Car table.   
16.	Create a view to display all drivers who own cars manufactured after 2019.
17.	Create a sequence to generate accident report numbers automatically and use it in an INSERT statement.
18.	Create a synonym for the Owns table and use it to list all driver‚Äìcar pairs.
19.	Create an index to improve the performance of queries filtering by damage_amount
*/ 

-- Drop existing tables if re-running the script
create database db;
USE db;
DROP TABLE IF EXISTS Participated;
DROP TABLE IF EXISTS Owns;
DROP TABLE IF EXISTS Accident;
DROP TABLE IF EXISTS Car;
DROP TABLE IF EXISTS Person;

-- Create Person table
CREATE TABLE Person (
    driver_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    address VARCHAR(100)
);

-- Create Car table
CREATE TABLE Car (
    license VARCHAR(20) PRIMARY KEY,
    model VARCHAR(50),
    year INT
);

-- Create Accident table
CREATE TABLE Accident (
    report_no INT AUTO_INCREMENT PRIMARY KEY,
    date_acc DATE,
    location VARCHAR(100)
);

-- Create Owns table
CREATE TABLE Owns (
    driver_id INT,
    license VARCHAR(20),
    PRIMARY KEY (driver_id, license),
    FOREIGN KEY (driver_id) REFERENCES Person(driver_id),
    FOREIGN KEY (license) REFERENCES Car(license)
);

-- Create Participated table
CREATE TABLE Participated (
    driver_id INT,
    model VARCHAR(50),
    report_no INT,
    damage_amount DECIMAL(10,2),
    FOREIGN KEY (driver_id) REFERENCES Person(driver_id),
    FOREIGN KEY (report_no) REFERENCES Accident(report_no)
);

-- Insert data into Person
INSERT INTO Person (driver_id, name, address) VALUES
(201, 'Rahul Sharma', 'Delhi'),
(202, 'Priya Verma', 'Mumbai'),
(203, 'Amit Patel', 'Ahmedabad');

-- Insert data into Car
INSERT INTO Car VALUES
('DL01AB1234', 'Hyundai i20', 2020),
('MH12CD5678', 'Honda City', 2018),
('GJ05EF4321', 'Tata Nexon', 2022);

-- Insert data into Accident
INSERT INTO Accident (report_no, date_acc, location) VALUES
(6001, '2025-01-10', 'Delhi'),
(6006, '2025-03-12', 'Mumbai'),
(6011, '2024-11-05', 'Ahmedabad');

-- Insert data into Owns
INSERT INTO Owns VALUES
(201, 'DL01AB1234'),
(202, 'MH12CD5678'),
(203, 'GJ05EF4321');

-- Insert data into Participated
INSERT INTO Participated VALUES
(201, 'Hyundai i20', 6001, 15000.00),
(202, 'Honda City', 6006, 25000.00),
(203, 'Tata Nexon', 6011, 18000.00);

-- Create views
CREATE OR REPLACE VIEW Driver_Car_View AS
SELECT p.name, c.model, c.year
FROM Person p
JOIN Owns o ON p.driver_id = o.driver_id
JOIN Car c ON o.license = c.license;

-- Create another view for high-damage drivers
CREATE OR REPLACE VIEW High_Damage_Drivers AS
SELECT p.name, pa.damage_amount
FROM Person p
JOIN Participated pa ON p.driver_id = pa.driver_id
WHERE pa.damage_amount > 20000;

-- Add a new person (AUTO_INCREMENT handles driver_id)
INSERT INTO Person (name, address)
VALUES ('Neha Singh', 'Bangalore');

-- Create indexes
CREATE INDEX idx_car_model_year ON Car(model, year);
CREATE UNIQUE INDEX idx_car_license_unique ON Car(license);
CREATE INDEX idx_participated_damage ON Participated(damage_amount);

-- Create a simple view for recent accidents (2025)
CREATE OR REPLACE VIEW Recent_Accidents AS
SELECT * FROM Accident
WHERE YEAR(date_acc) = 2025;

-- Create a view for new car drivers
CREATE OR REPLACE VIEW New_Car_Drivers AS
SELECT p.name, c.model, c.year
FROM Person p
JOIN Owns o ON p.driver_id = o.driver_id
JOIN Car c ON o.license = c.license
WHERE c.year > 2019;

-- Create another view for Owns table
CREATE OR REPLACE VIEW owns_info AS SELECT * FROM Owns;

-- Query to check joined data
SELECT p.name, c.model
FROM owns_info o
JOIN Person p ON o.driver_id = p.driver_id
JOIN Car c ON o.license = c.license;


/* 2.	Unnamed PL/SQL code block: Use of Control structure and Exception handling is mandatory.
Write a PL/SQL block of code for the following requirements:- Consider table Stud(Roll, Att,Status) 
Write a PL/SQL block for following requirement and handle the exceptions. Roll no. of student will be entered by user.
Attendance of roll no. entered by user will be checked in Stud table. If attendance is less than 75% then display the message
‚ÄúTerm not granted‚Äù and set the status in stud table as ‚ÄúD‚Äù. Otherwise display message ‚ÄúTerm granted‚Äù and set the status in stud table as ‚ÄúND‚Äù 
*/ 

// Database Stud
CREATE TABLE Stud (
    Roll NUMBER PRIMARY KEY,
    Name VARCHAR2(50),
    Att NUMBER,
    Status CHAR(2)
);

INSERT INTO Stud VALUES (101, 'Rahul', 82, NULL);
INSERT INTO Stud VALUES (102, 'Priya', 65, NULL);
COMMIT;
// database Stud complete here 

SET SERVEROUTPUT ON;

DECLARE
    v_roll   NUMBER;
    v_att    NUMBER;
BEGIN
    v_roll := &Roll;

    SELECT att INTO v_att 
    FROM Stud 
    WHERE Roll = v_roll;

    IF v_att < 75 THEN
        DBMS_OUTPUT.PUT_LINE('Term not granted');
        UPDATE Stud
        SET Status = 'D'
        WHERE Roll = v_roll;
    ELSE
        DBMS_OUTPUT.PUT_LINE('Term granted');
        UPDATE Stud
        SET Status = 'ND'
        WHERE Roll = v_roll;
    END IF;

    COMMIT;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Roll number not found in Stud table.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);
END;
/



/* 3.	Create Customer and Account table and add rows shown below 
1. Show the cname, Acc_Type, amount information of customer who is having an saving account.
2. Display the data using Natural, left and right join.
3. Display the information of customers living in the same city as of ‚Äòpooja‚Äô.
4. Display the information of account, having less amount than average amount throughout the bank.
5. Display the C_id having maximum amount in account.
6. Display the amount and acc_type of those customers whose amount is the minimum amount of that Acc_type.
7. Display the amount of those accounts whose amount is higher than amount of any saving account amount.
*/

create database db1;
USE db1;

-- Drop tables if re-running the script
DROP TABLE IF EXISTS Account;
DROP TABLE IF EXISTS Customer;

-- Step 1: Create Tables
CREATE TABLE Customer (
    C_id INT PRIMARY KEY,
    Cname VARCHAR(50),
    City VARCHAR(50)
);

CREATE TABLE Account (
    Acc_no INT PRIMARY KEY,
    C_id INT,
    Acc_Type VARCHAR(20),
    Amount DECIMAL(10,2),
    FOREIGN KEY (C_id) REFERENCES Customer(C_id)
);

-- Step 2: Insert Data
INSERT INTO Customer VALUES 
(1, 'Pooja', 'Pune'),
(2, 'Rahul', 'Pune'),
(3, 'Neha', 'Mumbai'),
(4, 'Amit', 'Delhi'),
(5, 'Priya', 'Pune');

INSERT INTO Account VALUES
(101, 1, 'Saving', 25000),
(102, 2, 'Current', 50000),
(103, 3, 'Saving', 15000),
(104, 4, 'Saving', 40000),
(105, 5, 'Current', 20000);

COMMIT;

------------------------------------------------------
-- üîπ QUERY 1: Show cname, Acc_Type, amount of customers having Saving account
------------------------------------------------------
SELECT c.Cname, a.Acc_Type, a.Amount
FROM Customer c
JOIN Account a ON c.C_id = a.C_id
WHERE a.Acc_Type = 'Saving';

------------------------------------------------------
-- üîπ QUERY 2: Display the data using Natural, Left and Right Join
------------------------------------------------------
-- Natural Join
SELECT * 
FROM Customer NATURAL JOIN Account;

-- Left Join
SELECT * 
FROM Customer c
LEFT JOIN Account a ON c.C_id = a.C_id;

-- Right Join
SELECT * 
FROM Customer c
RIGHT JOIN Account a ON c.C_id = a.C_id;

------------------------------------------------------
-- üîπ QUERY 3: Customers living in same city as 'Pooja'
------------------------------------------------------
SELECT * 
FROM Customer
WHERE City = (
    SELECT City FROM Customer WHERE Cname = 'Pooja'
);

------------------------------------------------------
-- üîπ QUERY 4: Accounts having less amount than average amount
------------------------------------------------------
SELECT * 
FROM Account
WHERE Amount < (SELECT AVG(Amount) FROM Account);

------------------------------------------------------
-- üîπ QUERY 5: C_id having maximum amount
------------------------------------------------------
SELECT C_id
FROM Account
WHERE Amount = (SELECT MAX(Amount) FROM Account);

------------------------------------------------------
-- üîπ QUERY 6: Amount and Acc_Type of customers whose amount 
--             is minimum for that Acc_Type
------------------------------------------------------
SELECT Acc_Type, Amount
FROM Account a
WHERE Amount = (
    SELECT MIN(Amount)
    FROM Account
    WHERE Acc_Type = a.Acc_Type
);

------------------------------------------------------
-- üîπ QUERY 7: Accounts whose amount is higher than 
--             any Saving account amount
------------------------------------------------------
SELECT *
FROM Account
WHERE Amount > ANY (
    SELECT Amount FROM Account WHERE Acc_Type = 'Saving'
);


/* 4.Unnamed PL/SQL code block: Use of Control structure and Exception handling is mandatory. 
Write a PL/SQL block of code for the following requirements:- 
Schema: 
1. Borrower(Rollin, Name, DateofIssue, NameofBook, Status) 
2. Fine(Roll_no,Date,Amt) 
Accept roll_no & name of book from user. 
Check the number of days (from date of issue), if days are between 15 to 30 then fine 
amount will be Rs 5per day. 
If no. of days>30, per day fine will be Rs 50 per day & for days less than 30, Rs. 5 per day. 
After submitting the book, status will change from I to R. 
If condition of fine is true, then details will be stored into fine table. 
*/

-- Drop tables if re-running
DROP TABLE Fine;
DROP TABLE Borrower;

-- Create Borrower table
CREATE TABLE Borrower (
    Rollno NUMBER PRIMARY KEY,
    Name VARCHAR2(50),
    DateofIssue DATE,
    NameofBook VARCHAR2(50),
    Status CHAR(1)
);

-- Create Fine table
CREATE TABLE Fine (
    Roll_no NUMBER,
    Date_of_Fine DATE,
    Amt NUMBER(10,2)
);

-- Insert sample data
INSERT INTO Borrower VALUES (101, 'Rahul', TO_DATE('2025-10-01', 'YYYY-MM-DD'), 'DBMS', 'I');
INSERT INTO Borrower VALUES (102, 'Priya', TO_DATE('2025-09-25', 'YYYY-MM-DD'), 'Networking', 'I');
INSERT INTO Borrower VALUES (103, 'Amit', TO_DATE('2025-10-25', 'YYYY-MM-DD'), 'Java', 'I');

COMMIT;

DECLARE
    v_roll      NUMBER;
    v_book      VARCHAR2(50);
    v_issue_dt  DATE;
    v_days      NUMBER;
    v_fine_amt  NUMBER := 0;
BEGIN
    -- Accept input from user
    v_roll := &Roll_No;
    v_book := '&Book_Name';

    -- Get date of issue for entered roll number and book
    SELECT DateofIssue INTO v_issue_dt
    FROM Borrower
    WHERE Rollno = v_roll AND NameofBook = v_book;

    -- Calculate number of days between issue date and today
    v_days := TRUNC(SYSDATE - v_issue_dt);

    -- Determine fine amount using control structure
    IF v_days > 30 THEN
        v_fine_amt := (v_days - 30) * 50 + (30 - 15) * 5; 
        -- fine = Rs. 5/day for 15‚Äì30 + Rs. 50/day beyond 30
    ELSIF v_days >= 15 THEN
        v_fine_amt := (v_days - 15) * 5;
    ELSE
        v_fine_amt := 0;
    END IF;

    -- Update book status to 'R' (Returned)
    UPDATE Borrower
    SET Status = 'R'
    WHERE Rollno = v_roll AND NameofBook = v_book;

    -- If fine exists, insert record into Fine table
    IF v_fine_amt > 0 THEN
        INSERT INTO Fine VALUES (v_roll, SYSDATE, v_fine_amt);
        DBMS_OUTPUT.PUT_LINE('Fine applied: Rs. ' || v_fine_amt);
    ELSE
        DBMS_OUTPUT.PUT_LINE('No fine. Returned within time.');
    END IF;

    COMMIT;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Roll number or book not found.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);
END;
/



/* 5.Create following tables with primary and foreign key and solve the queries given below
student(S_ID,name,dept_name,tot_cred) 
instructor(T_ID,name,dept_name,salary) 
course(course_id,title,dept_name,credits) 
i. Find the average salary of instructor in those departments where the average salary is more than Rs. 42000/-. 
ii. Increase the salary of each instructor in the computer department by 10%. 
iii. Find the names of instructors whose names are neither ‚ÄòAmol‚Äô nor ‚ÄòAmit‚Äô. 
iv. Find the names of student which contains ‚Äòam‚Äô as its substring. 
v. Find the name of students from computer department that ‚ÄúDBMS‚Äù courses they take. 
*/

// NOT SURE THIS IS CORRECT 

-- Create database and use it
CREATE DATABASE IF NOT EXISTS collegeDB;
USE collegeDB;

-- Drop existing tables if any
DROP TABLE IF EXISTS course;
DROP TABLE IF EXISTS instructor;
DROP TABLE IF EXISTS student;

------------------------------------------------------------
-- Step 1: Create Tables
------------------------------------------------------------
CREATE TABLE student (
    S_ID INT PRIMARY KEY,
    name VARCHAR(50),
    dept_name VARCHAR(50),
    tot_cred INT
);

CREATE TABLE instructor (
    T_ID INT PRIMARY KEY,
    name VARCHAR(50),
    dept_name VARCHAR(50),
    salary DECIMAL(10,2),
    UNIQUE (dept_name)  -- ‚úÖ Needed to allow foreign key reference
);

CREATE TABLE course (
    course_id INT PRIMARY KEY,
    title VARCHAR(50),
    dept_name VARCHAR(50),
    credits INT,
    FOREIGN KEY (dept_name) REFERENCES instructor(dept_name)
);

------------------------------------------------------------
-- Step 2: Insert Sample Data
------------------------------------------------------------
INSERT INTO student VALUES
(1, 'Aman', 'Computer', 120),
(2, 'Amrita', 'IT', 100),
(3, 'Suman', 'Computer', 110),
(4, 'Ramesh', 'Mechanical', 90),
(5, 'Neha', 'Computer', 105);

INSERT INTO instructor VALUES
(101, 'Amol', 'Computer', 40000),
(102, 'Amit', 'IT', 45000),
(103, 'Pooja', 'Computer', 55000),
(104, 'Rahul', 'Mechanical', 38000),
(105, 'Sneha', 'Electrical', 60000);

INSERT INTO course VALUES
(201, 'DBMS', 'Computer', 4),
(202, 'Operating System', 'Computer', 3),
(203, 'Networks', 'IT', 3),
(204, 'Thermodynamics', 'Mechanical', 3),
(205, 'Electrical Circuits', 'Electrical', 4);

COMMIT;

------------------------------------------------------------
-- ‚úÖ QUERY i: Average salary of instructors 
--    in departments where avg salary > 42000
------------------------------------------------------------
SELECT dept_name, AVG(salary) AS avg_salary
FROM instructor
GROUP BY dept_name
HAVING AVG(salary) > 42000;

------------------------------------------------------------
-- ‚úÖ QUERY ii: Increase salary of instructors 
--    in Computer department by 10%
------------------------------------------------------------
UPDATE instructor
SET salary = salary * 1.10
WHERE dept_name = 'Computer';

SELECT * FROM instructor; -- check updated salary

------------------------------------------------------------
-- ‚úÖ QUERY iii: Instructors whose names are 
--    neither 'Amol' nor 'Amit'
------------------------------------------------------------
SELECT name
FROM instructor
WHERE name NOT IN ('Amol', 'Amit');

------------------------------------------------------------
-- ‚úÖ QUERY iv: Students whose names contain 'am' 
--    as substring (case-insensitive)
------------------------------------------------------------
SELECT name
FROM student
WHERE LOWER(name) LIKE '%am%';

------------------------------------------------------------
-- ‚úÖ QUERY v: Names of students from Computer dept 
--    that take 'DBMS' course
------------------------------------------------------------
SELECT s.name AS Student_Name, c.title AS Course
FROM student s
JOIN course c ON s.dept_name = c.dept_name
WHERE s.dept_name = 'Computer'
AND c.title = 'DBMS';


/* 6.Cursors: (Implicit and Explicit Cursor). 
Write a PL/SQL block of code using parameterized Cursor, 
that will merge the data available in the newly created table N_RollCall 
with the data available in the table O_RollCall. 
If the data in the first table already exist in the second table then
 that data should be skipped.*/ 

-- PURPOSE: Create target table that will receive merged data
CREATE TABLE O_RollCall (
  student_id   NUMBER,
  student_name VARCHAR2(100),
  class_name   VARCHAR2(50),
  roll_no      NUMBER,
  attend_date  DATE,
  CONSTRAINT pk_o_roll PRIMARY KEY (student_id, attend_date)
);

-- PURPOSE: Create source table containing new records
CREATE TABLE N_RollCall (
  student_id   NUMBER,
  student_name VARCHAR2(100),
  class_name   VARCHAR2(50),
  roll_no      NUMBER,
  attend_date  DATE
);

-- PURPOSE: Insert sample data into N_RollCall
INSERT INTO N_RollCall VALUES (101, 'Asha Kapoor', '10A', 1, DATE '2025-11-01');
INSERT INTO N_RollCall VALUES (102, 'Ravi Singh',  '10A', 2, DATE '2025-11-01');
INSERT INTO N_RollCall VALUES (103, 'Meera Patel',  '10B', 3, DATE '2025-11-01');
INSERT INTO N_RollCall VALUES (101, 'Asha Kapoor', '10A', 1, DATE '2025-11-02');
COMMIT;

-- PURPOSE: Insert one row into O_RollCall to show skipping behavior
INSERT INTO O_RollCall VALUES (101, 'Asha Kapoor', '10A', 1, DATE '2025-11-01');
COMMIT;

-- PURPOSE: PL/SQL block to merge data using parameterized explicit cursor
--          and implicit cursor loop; skip rows that already exist
SET SERVEROUTPUT ON
DECLARE
  CURSOR c_exists(p_sid NUMBER, p_adate DATE) IS
    SELECT 1 FROM O_RollCall
    WHERE student_id = p_sid
      AND attend_date = p_adate;

  v_dummy NUMBER;
BEGIN
  FOR rec IN (SELECT student_id, student_name, class_name, roll_no, attend_date
              FROM N_RollCall) LOOP

    v_dummy := NULL;
    OPEN c_exists(rec.student_id, rec.attend_date);
    FETCH c_exists INTO v_dummy;

    IF c_exists%FOUND THEN
      NULL;  -- PURPOSE: Skip existing rows
    ELSE
      -- PURPOSE: Insert non-duplicate row
      INSERT INTO O_RollCall (student_id, student_name, class_name, roll_no, attend_date)
      VALUES (rec.student_id, rec.student_name, rec.class_name, rec.roll_no, rec.attend_date);
    END IF;

    CLOSE c_exists;
  END LOOP;

  COMMIT;
  DBMS_OUTPUT.PUT_LINE('Merge complete.');
END;
/

-- PURPOSE: View merged final output
SELECT * FROM O_RollCall ORDER BY student_id, attend_date;


/*7.Write a Stored Procedure namely proc_Grade for the categorization of student. 
If marks scored by students in examination is <=1500 and marks>=990 then student will be placed
 in distinction category if marks scored are between 989 and900 category is first class,
 if marks 899 and 825 category is Higher Second Class Write a PL/SQL block for using procedure created with above requirement. 
Stud_Marks(name, total_marks) Result(Roll,Name, Class). */


 -- PURPOSE: Create source table for student marks
CREATE TABLE Stud_Marks (
  name         VARCHAR2(100),
  total_marks  NUMBER
);

-- PURPOSE: Create result table where categorized output will be stored
CREATE TABLE Result (
  roll   NUMBER GENERATED ALWAYS AS IDENTITY,
  name   VARCHAR2(100),
  class  VARCHAR2(50)
);

-- PURPOSE: Stored Procedure proc_Grade
--          Categorizes student based on total_marks
CREATE OR REPLACE PROCEDURE proc_Grade(p_name IN VARCHAR2, p_marks IN NUMBER) AS
  v_class VARCHAR2(50);
BEGIN
  IF p_marks <= 1500 AND p_marks >= 990 THEN
    v_class := 'Distinction';
  ELSIF p_marks BETWEEN 900 AND 989 THEN
    v_class := 'First Class';
  ELSIF p_marks BETWEEN 825 AND 899 THEN
    v_class := 'Higher Second Class';
  ELSE
    v_class := 'Not Categorized';
  END IF;

  INSERT INTO Result(name, class)
  VALUES (p_name, v_class);
END;
/

-- PURPOSE: Insert sample data into Stud_Marks table
INSERT INTO Stud_Marks VALUES ('Asha', 1200);
INSERT INTO Stud_Marks VALUES ('Ravi', 950);
INSERT INTO Stud_Marks VALUES ('Meera', 860);
INSERT INTO Stud_Marks VALUES ('Karan', 700);   -- falls outside categories
COMMIT;

-- PURPOSE: PL/SQL block to call stored procedure proc_Grade
--          Reads each student and sends data to procedure
SET SERVEROUTPUT ON
BEGIN
  FOR rec IN (SELECT name, total_marks FROM Stud_Marks) LOOP
    proc_Grade(rec.name, rec.total_marks);
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('Grade assignment complete.');
END;
/

-- PURPOSE: View categorized results
SELECT * FROM Result;




/* 8.Write a PL/SQL code block to calculate the area of a circle for a value of radius varying from 5 to 9. Store the radius and the corresponding values of calculated area in an empty table named areas, consisting of two columns, radius and area.  */ 

-- PURPOSE: Create empty table to store radius and calculated area
CREATE TABLE areas (
  radius NUMBER,
  area   NUMBER
);

-- PURPOSE: PL/SQL block to calculate area of circle for radius 5 to 9
--          and insert each (radius, area) pair into areas table
SET SERVEROUTPUT ON
BEGIN
  FOR r IN 5..9 LOOP
    INSERT INTO areas(radius, area)
    VALUES (r, 3.14159 * r * r);   -- area = œÄr¬≤
  END LOOP;

  COMMIT;
  DBMS_OUTPUT.PUT_LINE('Area calculation complete.');
END;
/

-- PURPOSE: View stored areas
SELECT * FROM areas ORDER BY radius;


/* 9.Write a database trigger on Library table. The System should keep track of the
records that are being updated or deleted. 
The old value of updated or deleted records should be added in Library_ Audit table. 
Frame the problem statement for writing Database Triggers of all types, 
in-line with above statement.
 The problem statement should clearly state the requirements.
  */ 

/* 
PURPOSE: Problem Statement for All Trigger Types (row-level + statement-level)

1. The library system must record every update or delete performed on the Library table.
2. Before any record is updated or deleted, the old values must be copied into a Library_Audit table.
3. The audit table must store: BookID, Title, Author, Category, Operation_Type (UPDATE/DELETE), Operation_Date.
4. A BEFORE UPDATE OR DELETE row-level trigger must save old data into Library_Audit.
5. A AFTER UPDATE OR DELETE statement-level trigger must record that an update/delete operation happened.
6. A BEFORE INSERT trigger should check for invalid data (for example missing title or negative price).
7. An AFTER INSERT trigger may log that a new book record has been added.
*/

/* PURPOSE: Create main table for library records */
CREATE TABLE Library (
  BookID    NUMBER PRIMARY KEY,
  Title     VARCHAR2(200),
  Author    VARCHAR2(200),
  Category  VARCHAR2(100),
  Price     NUMBER
);

/* PURPOSE: Create audit table to store OLD values for update/delete actions */
CREATE TABLE Library_Audit (
  AuditID       NUMBER GENERATED ALWAYS AS IDENTITY,
  BookID        NUMBER,
  Title         VARCHAR2(200),
  Author        VARCHAR2(200),
  Category      VARCHAR2(100),
  Price         NUMBER,
  OperationType VARCHAR2(20),
  OperationDate DATE
);

/* PURPOSE: BEFORE UPDATE OR DELETE trigger to store old values in audit table */
CREATE OR REPLACE TRIGGER trg_library_audit_row
BEFORE UPDATE OR DELETE ON Library
FOR EACH ROW
BEGIN
  INSERT INTO Library_Audit (BookID, Title, Author, Category, Price, OperationType, OperationDate)
  VALUES (:OLD.BookID, :OLD.Title, :OLD.Author, :OLD.Category, :OLD.Price,
          CASE 
            WHEN UPDATING THEN 'UPDATE'
            WHEN DELETING THEN 'DELETE'
          END,
          SYSDATE);
END;
/

/* PURPOSE: AFTER UPDATE or DELETE statement-level trigger to log activity at statement level */
CREATE OR REPLACE TRIGGER trg_library_audit_stmt
AFTER UPDATE OR DELETE ON Library
BEGIN
  DBMS_OUTPUT.PUT_LINE('A library record operation occurred.');
END;
/

/* PURPOSE: BEFORE INSERT trigger to validate new records */
CREATE OR REPLACE TRIGGER trg_library_validate
BEFORE INSERT ON Library
FOR EACH ROW
BEGIN
  IF :NEW.Title IS NULL THEN
    RAISE_APPLICATION_ERROR(-20001, 'Title cannot be empty.');
  END IF;

  IF :NEW.Price < 0 THEN
    RAISE_APPLICATION_ERROR(-20002, 'Price cannot be negative.');
  END IF;
END;
/

/* PURPOSE: AFTER INSERT trigger to confirm successful insertion */
CREATE OR REPLACE TRIGGER trg_library_log_insert
AFTER INSERT ON Library
BEGIN
  DBMS_OUTPUT.PUT_LINE('A new book record has been added.');
END;
/

/* PURPOSE: Sample data for testing triggers */
INSERT INTO Library VALUES (1, 'The Alchemist', 'Paulo Coelho', 'Fiction', 350);
INSERT INTO Library VALUES (2, 'Clean Code', 'Robert Martin', 'Programming', 550);
COMMIT;

/* PURPOSE: Test update operation */
UPDATE Library SET Price = 375 WHERE BookID = 1;

/* PURPOSE: Test delete operation */
DELETE FROM Library WHERE BookID = 2;

/* PURPOSE: View audit history */
SELECT * FROM Library_Audit ORDER BY AuditID;



/*  10. create Collection ‚Äúorderinfo‚Äú which contains the documents given as below(Perform on Mongo Terminal) 
{ 
cust_id:123 
cust_name:‚Äùabc‚Äù, 
status:‚ÄùA‚Äù, 
price:250 
} 
1)	find the average price for each customers having status 'A' 
2)	Display the status of the customers whose amount/price lie between 100 and 1000 
3)	Display the customers information without ‚Äú_id‚Äù . 
4)	create a simple index on onderinfo collection and fire the queries. 
 */ 

// PURPOSE: Switch to or create a database (e.g., shopDB)
use shopDB

// PURPOSE: Create "orderinfo" collection and insert a document
db.orderinfo.insertOne({
  cust_id: 123,
  cust_name: "abc",
  status: "A",
  price: 250
});

// PURPOSE: Insert some sample documents for testing
db.orderinfo.insertMany([
  { cust_id: 124, cust_name: "xyz", status: "A", price: 500 },
  { cust_id: 125, cust_name: "pqr", status: "B", price: 150 },
  { cust_id: 126, cust_name: "lmn", status: "A", price: 800 },
  { cust_id: 127, cust_name: "def", status: "B", price: 50 }
]);

// 1) PURPOSE: Find average price for each customer with status 'A'
db.orderinfo.aggregate([
  { $match: { status: "A" } },
  { $group: { _id: "$cust_name", avgPrice: { $avg: "$price" } } }
]);

// 2) PURPOSE: Display status of customers whose price is between 100 and 1000
db.orderinfo.find(
  { price: { $gte: 100, $lte: 1000 } },
  { _id: 0, cust_name: 1, status: 1, price: 1 }
);

// 3) PURPOSE: Display customer information without "_id"
db.orderinfo.find({}, { _id: 0 });

// 4) PURPOSE: Create a simple index on "cust_id" field
db.orderinfo.createIndex({ cust_id: 1 });

// PURPOSE: Fire the previous queries again using the index
db.orderinfo.aggregate([
  { $match: { status: "A" } },
  { $group: { _id: "$cust_name", avgPrice: { $avg: "$price" } } }
]);

db.orderinfo.find(
  { price: { $gte: 100, $lte: 1000 } },
  { _id: 0, cust_name: 1, status: 1, price: 1 }
);

db.orderinfo.find({}, { _id: 0 });



/* 11.Create Collection ‚Äúmovies‚Äú which contains the documents given as below(Perform on Mongo Terminal) 
{ 
name: ‚ÄúMovie1‚Äù, 
type: ‚Äúaction‚Äù, 
budget:1000000 
producer:{ 
name: ‚Äúproducer1‚Äù, 
address:‚ÄùPUNE‚Äù 
} 
} 
i. Find the name of the movie having budget greater than 1,00,000. 
ii. Find the name of producer who lives in Pune 
iii. Update the type of movie ‚Äúaction‚Äù to ‚Äúhorror‚Äù 
iv. Find all the documents produced by name ‚Äúproducer1‚Äù with their address 
 */ 

// PURPOSE: Switch to or create a database (e.g., filmDB)
use filmDB

// PURPOSE: Create "movies" collection and insert a document
db.movies.insertOne({
  name: "Movie1",
  type: "action",
  budget: 1000000,
  producer: {
    name: "producer1",
    address: "PUNE"
  }
});

// PURPOSE: Insert more sample documents for testing
db.movies.insertMany([
  {
    name: "Movie2",
    type: "drama",
    budget: 500000,
    producer: { name: "producer2", address: "MUMBAI" }
  },
  {
    name: "Movie3",
    type: "action",
    budget: 200000,
    producer: { name: "producer1", address: "PUNE" }
  }
]);

// i. PURPOSE: Find name of movie having budget greater than 100000
db.movies.find(
  { budget: { $gt: 100000 } },
  { _id: 0, name: 1 }
);

// ii. PURPOSE: Find name of producer who lives in PUNE
db.movies.find(
  { "producer.address": "PUNE" },
  { _id: 0, "producer.name": 1 }
);

// iii. PURPOSE: Update the type of movie "action" to "horror"
db.movies.updateMany(
  { type: "action" },
  { $set: { type: "horror" } }
);

// iv. PURPOSE: Find all documents produced by "producer1" with their address
db.movies.find(
  { "producer.name": "producer1" },
  { _id: 0, name: 1, "producer.name": 1, "producer.address": 1 }
);


/* 12.Consider following structure for Mongodb collection and write a query for following requirements in Mongodb 
Teachers (Tname,dno,Experience,Salary,Date_of_Joining) 
Department (Dno,Dname) 
Students(Sname,Roll_No,Class) 
1. Write a query to create above collection insert some sample documents. 
2. Find the information about all teachers of Dno=2 and having salary greater than or equal to 10,000/- 
3. Find the student information having Roll_no=2 or Sname='xyz' 
4. Update student name whose Roll_No=5 
5. Delete all student whose Class is 'FE' 
6. Apply index on Students Collection 
 */ 

// PURPOSE: Switch to or create a database (e.g., schoolDB)
use schoolDB

// 1. PURPOSE: Create Teachers, Department, and Students collections and insert sample documents

// Teachers Collection
db.Teachers.insertMany([
  { Tname: "Mr. Sharma", dno: 1, Experience: 10, Salary: 12000, Date_of_Joining: ISODate("2015-06-01") },
  { Tname: "Ms. Rao", dno: 2, Experience: 5, Salary: 15000, Date_of_Joining: ISODate("2018-01-15") },
  { Tname: "Mr. Mehta", dno: 2, Experience: 8, Salary: 9500, Date_of_Joining: ISODate("2016-09-10") }
]);

// Department Collection
db.Department.insertMany([
  { Dno: 1, Dname: "Computer" },
  { Dno: 2, Dname: "Mechanical" },
  { Dno: 3, Dname: "Electrical" }
]);

// Students Collection
db.Students.insertMany([
  { Sname: "abc", Roll_No: 1, Class: "SE" },
  { Sname: "xyz", Roll_No: 2, Class: "TE" },
  { Sname: "pqr", Roll_No: 3, Class: "FE" },
  { Sname: "lmn", Roll_No: 5, Class: "BE" },
  { Sname: "stu", Roll_No: 6, Class: "FE" }
]);

// 2. PURPOSE: Find all teachers of dno=2 with salary >= 10000
db.Teachers.find(
  { dno: 2, Salary: { $gte: 10000 } },
  { _id: 0 }
);

// 3. PURPOSE: Find student info with Roll_No=2 OR Sname='xyz'
db.Students.find(
  { $or: [ { Roll_No: 2 }, { Sname: "xyz" } ] },
  { _id: 0 }
);

// 4. PURPOSE: Update student name whose Roll_No=5
db.Students.updateOne(
  { Roll_No: 5 },
  { $set: { Sname: "UpdatedName" } }
);

// 5. PURPOSE: Delete all students whose Class is 'FE'
db.Students.deleteMany(
  { Class: "FE" }
);

// 6. PURPOSE: Apply index on Students collection (e.g., on Roll_No)
db.Students.createIndex({ Roll_No: 1 });

// OPTIONAL: Verify Students collection after deletion and update
db.Students.find({}, { _id: 0 });


/* 13.Perform aggregation and Indexing using mongodb on below database 
1. Create a database department 
2. Create a collection as teacher with fields as name , department ,experience and salary 
3. Display the department wise average salary. 
4. Display the no. Of employees working in each department. 
5. Display the department wise minimum salary. 
6. Apply index and drop index 
 */ 

// 1. PURPOSE: Create or switch to database "department"
use department

// 2. PURPOSE: Create "teacher" collection and insert sample documents
db.teacher.insertMany([
  { name: "Mr. Sharma", department: "Computer", experience: 10, salary: 12000 },
  { name: "Ms. Rao", department: "Mechanical", experience: 5, salary: 15000 },
  { name: "Mr. Mehta", department: "Mechanical", experience: 8, salary: 9500 },
  { name: "Mrs. Joshi", department: "Computer", experience: 6, salary: 11000 },
  { name: "Mr. Verma", department: "Electrical", experience: 12, salary: 13000 }
]);

// 3. PURPOSE: Display department-wise average salary
db.teacher.aggregate([
  { $group: { _id: "$department", avgSalary: { $avg: "$salary" } } }
]);

// 4. PURPOSE: Display the number of employees working in each department
db.teacher.aggregate([
  { $group: { _id: "$department", totalEmployees: { $sum: 1 } } }
]);

// 5. PURPOSE: Display department-wise minimum salary
db.teacher.aggregate([
  { $group: { _id: "$department", minSalary: { $min: "$salary" } } }
]);

// 6. PURPOSE: Apply an index on "department" field
db.teacher.createIndex({ department: 1 });

// PURPOSE: Drop the index on "department" field
db.teacher.dropIndex("department_1");



/*  14.Collection ‚Äúcity ‚Äú which contains the documents given as below(Perform on Mongo Terminal) 
{ 
city:‚Äùpune‚Äù, 
type:‚Äùurban‚Äù, 
state:‚ÄùMH‚Äù, 
population:‚Äù5600000‚Äù 
} 
-using mapreduce, find statewise population 
-using mapreduce, find citywise population 
-using mapreduce, find typewise population. 
*/ 


// PURPOSE: Switch to or create a database (e.g., cityDB)
use cityDB

// PURPOSE: Create "city" collection and insert sample documents
db.city.insertMany([
  { city: "Pune", type: "urban", state: "MH", population: 5600000 },
  { city: "Mumbai", type: "urban", state: "MH", population: 12400000 },
  { city: "Nagpur", type: "urban", state: "MH", population: 2400000 },
  { city: "Nashik", type: "urban", state: "MH", population: 2000000 },
  { city: "Satara", type: "rural", state: "MH", population: 1500000 },
  { city: "Bangalore", type: "urban", state: "KA", population: 8400000 },
  { city: "Mysore", type: "urban", state: "KA", population: 920000 }
]);

// 1. PURPOSE: Statewise population using MapReduce
var mapState = function() {
  emit(this.state, this.population);
};

var reduceState = function(key, values) {
  return Array.sum(values);
};

db.city.mapReduce(mapState, reduceState, { out: "statewise_population" });

// Check statewise population
db.statewise_population.find();

// 2. PURPOSE: Citywise population using MapReduce
var mapCity = function() {
  emit(this.city, this.population);
};

var reduceCity = function(key, values) {
  return Array.sum(values);
};

db.city.mapReduce(mapCity, reduceCity, { out: "citywise_population" });

// Check citywise population
db.citywise_population.find();

// 3. PURPOSE: Typewise population using MapReduce
var mapType = function() {
  emit(this.type, this.population);
};

var reduceType = function(key, values) {
  return Array.sum(values);
};

db.city.mapReduce(mapType, reduceType, { out: "typewise_population" });

// Check typewise population
db.typewise_population.find();


/* 15.Collection creation Student and insert following data in that:
Rollno:1,name:'Navin',subject:'DMSA',marks:78
Rollno:2,name:'anusha',subject:'OSD',marks:75
Rollno:3,name:'ravi',subject:'TOC',marks:69
Rollno:4,name:'veena',subject:'TOC',marks:70
Rollno:5,name:‚ÄòPravini',subject:‚ÄòOSD',marks:80
Rollno:6,name: ‚ÄòReena',subject: ‚ÄòDMSA',marks:50
Rollno:7,name:‚ÄòGeeta',subject:‚ÄòCN',marks:90
Rollno:8,name:‚ÄòAkash',subject:‚ÄòCN',marks:85
1. Write aggregate function to find Max marks of Each Subject.
2. Write aggregate function to find Min marks of Each Subject.
3. Write aggregate function to find Sum of marks of Each Subject.
4. Write aggregate function to find Avg marks of Each Subject.
5. Write aggregate function to find first record Each Subject.
6. Write aggregate function to find Last record of Each Subject.
7. Write aggregate function to find count number of records of each subject
8. Write aggregate function to find count number of records of each subject
 */ 

// PURPOSE: Switch to or create a database (e.g., schoolDB)
use schoolDB

// PURPOSE: Create "Student" collection and insert documents
db.Student.insertMany([
  { Rollno: 1, name: 'Navin', subject: 'DMSA', marks: 78 },
  { Rollno: 2, name: 'Anusha', subject: 'OSD', marks: 75 },
  { Rollno: 3, name: 'Ravi', subject: 'TOC', marks: 69 },
  { Rollno: 4, name: 'Veena', subject: 'TOC', marks: 70 },
  { Rollno: 5, name: 'Pravini', subject: 'OSD', marks: 80 },
  { Rollno: 6, name: 'Reena', subject: 'DMSA', marks: 50 },
  { Rollno: 7, name: 'Geeta', subject: 'CN', marks: 90 },
  { Rollno: 8, name: 'Akash', subject: 'CN', marks: 85 }
]);

// 1. PURPOSE: Aggregate function to find Max marks of each subject
db.Student.aggregate([
  { $group: { _id: "$subject", maxMarks: { $max: "$marks" } } }
]);

// 2. PURPOSE: Aggregate function to find Min marks of each subject
db.Student.aggregate([
  { $group: { _id: "$subject", minMarks: { $min: "$marks" } } }
]);

// 3. PURPOSE: Aggregate function to find Sum of marks of each subject
db.Student.aggregate([
  { $group: { _id: "$subject", totalMarks: { $sum: "$marks" } } }
]);

// 4. PURPOSE: Aggregate function to find Avg marks of each subject
db.Student.aggregate([
  { $group: { _id: "$subject", avgMarks: { $avg: "$marks" } } }
]);

// 5. PURPOSE: Aggregate function to find first record of each subject
db.Student.aggregate([
  { $sort: { Rollno: 1 } },
  { $group: { _id: "$subject", firstRecord: { $first: "$$ROOT" } } }
]);

// 6. PURPOSE: Aggregate function to find last record of each subject
db.Student.aggregate([
  { $sort: { Rollno: 1 } },
  { $group: { _id: "$subject", lastRecord: { $last: "$$ROOT" } } }
]);

// 7. PURPOSE: Aggregate function to count number of records of each subject
db.Student.aggregate([
  { $group: { _id: "$subject", countRecords: { $sum: 1 } } }
]);

// 8. PURPOSE: (Repeated) Count number of records of each subject
db.Student.aggregate([
  { $group: { _id: "$subject", countRecords: { $sum: 1 } } }
]);


/* 16.Create database employee and create collection computer Define a map function to emit the "total" key and the "Salary" value for each document. Define a reduce function to sum the salaries associated with the "total" key. Execute the map-reduce operation on the "Computer" collection, 
specifying an output collection where the results will be stored. */ 

// 1. PURPOSE: Switch to or create database "employee"
use employee

// 2. PURPOSE: Create "Computer" collection and insert sample documents
db.Computer.insertMany([
  { emp_id: 1, name: "Ravi", Salary: 50000 },
  { emp_id: 2, name: "Anusha", Salary: 60000 },
  { emp_id: 3, name: "Navin", Salary: 55000 },
  { emp_id: 4, name: "Veena", Salary: 65000 }
]);

// 3. PURPOSE: Define map function to emit "total" key and Salary value
var mapFunction = function() {
  emit("total", this.Salary);
};

// 4. PURPOSE: Define reduce function to sum the salaries
var reduceFunction = function(key, values) {
  return Array.sum(values);
};

// 5. PURPOSE: Execute map-reduce operation on "Computer" collection
db.Computer.mapReduce(
  mapFunction,
  reduceFunction,
  { out: "total_salary" }
);

// 6. PURPOSE: View the results of map-reduce
db.total_salary.find();


/* 17.Collection ‚Äúorderinfo‚Äú which contains the documents given as below(Perform on Mongo Terminal) 
{ 
cust_id:123 
cust_name:‚Äùabc‚Äù, 
status:‚ÄùA‚Äù, 
price:250 
} 
i. Display the name of the customer having the price between 250 and 450 
ii. Increment the price by 10 for cust_id: 123 and decrement the price by 5 for cust_id: 124 
iii. Remove any one of the field from the orderinfo collection. 
iv. Find the name of the customer whose status is either A or price is 250 or both.
  */ 

// PURPOSE: Switch to or create database (e.g., shopDB)
use shopDB

// PURPOSE: Create "orderinfo" collection and insert sample documents
db.orderinfo.insertMany([
  { cust_id: 123, cust_name: "abc", status: "A", price: 250 },
  { cust_id: 124, cust_name: "xyz", status: "B", price: 400 },
  { cust_id: 125, cust_name: "pqr", status: "A", price: 500 }
]);

// i. PURPOSE: Display the name of customer having price between 250 and 450
db.orderinfo.find(
  { price: { $gte: 250, $lte: 450 } },
  { _id: 0, cust_name: 1 }
);

// ii. PURPOSE: Increment price by 10 for cust_id 123 and decrement price by 5 for cust_id 124
db.orderinfo.updateOne(
  { cust_id: 123 },
  { $inc: { price: 10 } }
);
db.orderinfo.updateOne(
  { cust_id: 124 },
  { $inc: { price: -5 } }
);

// iii. PURPOSE: Remove any one field (e.g., "status") from all documents
db.orderinfo.updateMany(
  {},
  { $unset: { status: "" } }
);

// iv. PURPOSE: Find name of customer whose status is 'A' or price is 250 or both
db.orderinfo.find(
  { $or: [ { status: "A" }, { price: 250 } ] },
  { _id: 0, cust_name: 1 }
);


/* 18.Emp(emp_id,ename, street, city) 
works(emp_id,c_id,ename, cname, sal) 
Company(c_id,cname, city) 
Manager(mgr_id, mgrname) 
i. Modify the database so that a particular company (eg. ABC) now in Pune 
ii. Give all managers of Mbank a 10% raise. If salary is >20,000, give only 3% raise. 
iii. Find out the names of all the employees who works in ‚ÄòBosch‚Äô company in city Pune 
iv. Delete all records in the works table for employees of a particular company (Eg, SBC Company) whose salary>50,000. 

 */ 

-- 1. PURPOSE: Update the city of a particular company (e.g., ABC) to Pune
UPDATE Company
SET city = 'Pune'
WHERE cname = 'ABC';

-- 2. PURPOSE: Give managers of Mbank a salary raise based on conditions
-- Assuming salary is stored in 'works' table and managers are linked to company through 'c_id'
UPDATE works
SET sal = CASE 
            WHEN sal > 20000 THEN sal * 1.03
            ELSE sal * 1.10
          END
WHERE cname = 'Mbank';

-- 3. PURPOSE: Find names of all employees working in 'Bosch' in Pune
SELECT e.ename
FROM Emp e
JOIN works w ON e.emp_id = w.emp_id
JOIN Company c ON w.c_id = c.c_id
WHERE c.cname = 'Bosch' AND c.city = 'Pune';

-- 4. PURPOSE: Delete records from works table for employees of SBC Company with salary > 50000
DELETE FROM works
WHERE c_id = (SELECT c_id FROM Company WHERE cname = 'SBC')
  AND sal > 50000;


/* 
19.Create database Employee.
2.Create collection emp1 using createCollection method.
3.Insert 4 to 5 documents in emp1 collection.(eno,ename,address,sal)
4.display all documents.
5.Display all employess having salary greater than 5000
6.Display all employess having salary less than 15000
7.Display all employess having salary greater than 10000 and less than 20000.
8.Update sal of all employee with 10%
9.Delete employee having salary less than 5000.
10.Rename collection emp1 with employee1.
11.Display employee whose name start with n.
12.sort name in ascending order.
13.Create a new database with name Employee1.
14.Drop employee1 database.
15.Create collection emp1 using insert method.
16.Drop collection emp1.
  */ 

// 1. PURPOSE: Switch to or create database "Employee"
use Employee

// 2. PURPOSE: Create collection "emp1"
db.createCollection("emp1")

// 3. PURPOSE: Insert 4-5 documents into emp1
db.emp1.insertMany([
  { eno: 1, ename: "Navin", address: "Pune", sal: 12000 },
  { eno: 2, ename: "Anusha", address: "Mumbai", sal: 8000 },
  { eno: 3, ename: "Ravi", address: "Delhi", sal: 5000 },
  { eno: 4, ename: "Veena", address: "Chennai", sal: 15000 },
  { eno: 5, ename: "Nikita", address: "Bangalore", sal: 4500 }
]);

// 4. PURPOSE: Display all documents
db.emp1.find({})

// 5. PURPOSE: Display employees with salary greater than 5000
db.emp1.find({ sal: { $gt: 5000 } })

// 6. PURPOSE: Display employees with salary less than 15000
db.emp1.find({ sal: { $lt: 15000 } })

// 7. PURPOSE: Display employees with salary >10000 and <20000
db.emp1.find({ sal: { $gt: 10000, $lt: 20000 } })

// 8. PURPOSE: Update salary of all employees by 10%
db.emp1.updateMany({}, { $mul: { sal: 1.10 } })

// 9. PURPOSE: Delete employees with salary less than 5000
db.emp1.deleteMany({ sal: { $lt: 5000 } })

// 10. PURPOSE: Rename collection "emp1" to "employee1"
db.emp1.renameCollection("employee1")

// 11. PURPOSE: Display employees whose name starts with "n" (case-insensitive)
db.employee1.find({ ename: { $regex: /^n/i } })

// 12. PURPOSE: Sort employees by name in ascending order
db.employee1.find().sort({ ename: 1 })

// 13. PURPOSE: Create a new database "Employee1"
use Employee1

// 14. PURPOSE: Drop database "Employee1"
db.dropDatabase()

// 15. PURPOSE: Create collection emp1 using insert method
db.emp1.insertOne({ eno: 1, ename: "Test", address: "City", sal: 1000 })

// 16. PURPOSE: Drop collection emp1
db.emp1.drop()


/* 20.Empl(e_no, e_name, post, pay_rate) 
Position(pos_no, post) 
Duty-alloc (pos_no, e_no, month,year, shift) 
Implement the following SQL queries 
i. Get duty allocation details for e_no 123 for the first shift in the month of April 2003 
ii. Get the employees whose rate of pay is > or equal rate of pay of employees 'Sachin'. 
iii. Create a view for displaying minimum, maximum and average salary for all the posts. 
iv. Get count of different employees on each shift having post ‚Äòmanager‚Äô. 
*/ 

-- i. Get duty allocation details for e_no 123 for the first shift in April 2003
SELECT *
FROM Duty_alloc
WHERE e_no = 123
  AND month = 'April'
  AND year = 2003
  AND shift = 1;

-- ii. Get employees whose pay_rate >= pay_rate of employee 'Sachin'
SELECT *
FROM Empl
WHERE pay_rate >= (SELECT pay_rate FROM Empl WHERE e_name = 'Sachin');

-- iii. Create a view for minimum, maximum, and average salary for all posts
CREATE VIEW Post_Salary_Stats AS
SELECT post,
       MIN(pay_rate) AS Min_Salary,
       MAX(pay_rate) AS Max_Salary,
       AVG(pay_rate) AS Avg_Salary
FROM Empl
GROUP BY post;

-- iv. Get count of different employees on each shift having post 'manager'
SELECT da.shift, COUNT(DISTINCT da.e_no) AS Employee_Count
FROM Duty_alloc da
JOIN Empl e ON da.e_no = e.e_no
WHERE e.post = 'manager'
GROUP BY da.shift;


/* 21.Employee(employee_name,street,city)
Works(employee_name,company_name,salary)
Company(company_name,city)
Manages(employee_name,manager_name)
 
1. Find the names of employees who work for First Bank Coorporation.
2. Find the names and cities of residence of all employees who work for First Bank Coorporation
3. Find the names, street addresses, and cities of residence of all employees who work for First Bank Coorporation and earn more than $10000. 
4.Find all employees in the database who lives in the same cities as tha companies for which they work.
5.Find all employees in the database who lives in the same cities and on the same streets as do their manager. 
6.Find all employees in the database who do not work for First Bank Coorporation
7.Give all employees of First Bank Coorporation‚Äù a 10% raise
8.Delete all tuples in the ‚ÄúWorks‚Äù relation for employees of ‚ÄúSmall Bank Coorporation‚Äù.
 */ 

-- 1. Find names of employees who work for First Bank Coorporation
SELECT e.employee_name
FROM Employee e
JOIN Works w ON e.employee_name = w.employee_name
WHERE w.company_name = 'First Bank Coorporation';

-- 2. Find names and cities of residence of employees who work for First Bank Coorporation
SELECT e.employee_name, e.city
FROM Employee e
JOIN Works w ON e.employee_name = w.employee_name
WHERE w.company_name = 'First Bank Coorporation';

-- 3. Find names, street addresses, and cities of employees who work for First Bank Coorporation and earn > 10000
SELECT e.employee_name, e.street, e.city
FROM Employee e
JOIN Works w ON e.employee_name = w.employee_name
WHERE w.company_name = 'First Bank Coorporation' AND w.salary > 10000;

-- 4. Find all employees who live in the same city as the companies they work for
SELECT e.employee_name, e.city AS employee_city, c.city AS company_city, w.company_name
FROM Employee e
JOIN Works w ON e.employee_name = w.employee_name
JOIN Company c ON w.company_name = c.company_name
WHERE e.city = c.city;

-- 5. Find all employees who live in the same city and street as their manager
SELECT e.employee_name, e.street, e.city, m.manager_name
FROM Employee e
JOIN Manages mg ON e.employee_name = mg.employee_name
JOIN Employee m ON mg.manager_name = m.employee_name
WHERE e.city = m.city AND e.street = m.street;

-- 6. Find all employees who do NOT work for First Bank Coorporation
SELECT e.employee_name
FROM Employee e
JOIN Works w ON e.employee_name = w.employee_name
WHERE w.company_name <> 'First Bank Coorporation';

-- 7. Give all employees of First Bank Coorporation a 10% raise
UPDATE Works
SET salary = salary * 1.10
WHERE company_name = 'First Bank Coorporation';

-- 8. Delete all tuples in Works for employees of Small Bank Coorporation
DELETE FROM Works
WHERE company_name = 'Small Bank Coorporation';

/* 22.Employee(employee_name,street,city)
Works(employee_name,company_name,salary)
Company(company_name,city)
Manages(employee_name,manager_name)
1)	Find all employees in the database who earn more than each employee of  Small  Bank  Coorporation
2)	Assume that the company is may be located in several cities. Find all companies located in every city in which Small Bank Coorporation is located.
3)	Find all employees who earn more than the average salary of all employees of their companies.
4)	Find the company that has the most employees.
5)	Find the company that has the smallest payroll.
6)	Find those companies whose employees earn a higher salary, on average, than the average salary at First Bank Coorporation. 
7)	Modify the database so that ‚ÄúJones‚Äù now lives in Newtown.
 */ 

-- 1) Find all employees who earn more than each employee of Small Bank Coorporation
SELECT e.employee_name, w.salary
FROM Employee e
JOIN Works w ON e.employee_name = w.employee_name
WHERE w.salary > ALL (
    SELECT salary 
    FROM Works 
    WHERE company_name = 'Small Bank Coorporation'
);

-- 2) Find all companies located in every city in which Small Bank Coorporation is located
SELECT c.company_name
FROM Company c
WHERE NOT EXISTS (
    SELECT sbc.city
    FROM Company sbc
    WHERE sbc.company_name = 'Small Bank Coorporation'
      AND sbc.city NOT IN (
        SELECT c2.city
        FROM Company c2
        WHERE c2.company_name = c.company_name
      )
);

-- 3) Find all employees who earn more than the average salary of all employees of their company
SELECT e.employee_name, w.salary, w.company_name
FROM Employee e
JOIN Works w ON e.employee_name = w.employee_name
WHERE w.salary > (
    SELECT AVG(salary)
    FROM Works
    WHERE company_name = w.company_name
);

-- 4) Find the company that has the most employees
SELECT w.company_name, COUNT(*) AS employee_count
FROM Works w
GROUP BY w.company_name
ORDER BY employee_count DESC
FETCH FIRST 1 ROW ONLY;

-- 5) Find the company that has the smallest payroll
SELECT w.company_name, SUM(w.salary) AS total_payroll
FROM Works w
GROUP BY w.company_name
ORDER BY total_payroll ASC
FETCH FIRST 1 ROW ONLY;

-- 6) Find companies whose employees earn higher salary on average than First Bank Coorporation
SELECT w.company_name
FROM Works w
GROUP BY w.company_name
HAVING AVG(w.salary) > (
    SELECT AVG(salary) 
    FROM Works 
    WHERE company_name = 'First Bank Coorporation'
);

-- 7) Modify the database so that "Jones" now lives in Newtown
UPDATE Employee
SET city = 'Newtown'
WHERE employee_name = 'Jones';


/* 23.Create a table emp with following fields and constraints 
Eno ‚Äì(Constraint:- primary key and apply sequence starts with 101) ,Ename ‚Äì(Constraint :- not null) 
Address ‚Äì‚Äì(Constraint :-default ‚ÄòNashik‚Äô) ,Joindate, 
After table creation add field - Post in the emp table. 
Insert some data in emp table.Create Index on Ename field of employee table. 
Create View on employee table to show only Ename and Salary. 
 */ 

-- 1. PURPOSE: Create sequence for employee numbers starting from 101
CREATE SEQUENCE emp_seq
START WITH 101
INCREMENT BY 1
NOCACHE
NOCYCLE;

-- 2. PURPOSE: Create table "emp" with constraints
CREATE TABLE emp (
    Eno NUMBER PRIMARY KEY,
    Ename VARCHAR2(100) NOT NULL,
    Address VARCHAR2(100) DEFAULT 'Nashik',
    Joindate DATE,
    Salary NUMBER
);

-- 3. PURPOSE: Add field "Post" to emp table
ALTER TABLE emp
ADD Post VARCHAR2(50);

-- 4. PURPOSE: Insert sample data into emp table using sequence
INSERT INTO emp (Eno, Ename, Address, Joindate, Salary, Post)
VALUES (emp_seq.NEXTVAL, 'Navin', 'Pune', DATE '2023-01-15', 50000, 'Manager');

INSERT INTO emp (Eno, Ename, Address, Joindate, Salary, Post)
VALUES (emp_seq.NEXTVAL, 'Anusha', DEFAULT, DATE '2022-07-10', 45000, 'Developer');

INSERT INTO emp (Eno, Ename, Address, Joindate, Salary, Post)
VALUES (emp_seq.NEXTVAL, 'Ravi', 'Mumbai', DATE '2021-03-20', 40000, 'Analyst');

-- 5. PURPOSE: Create index on Ename field
CREATE INDEX idx_emp_name ON emp(Ename);

-- 6. PURPOSE: Create a view to show only Ename and Salary
CREATE VIEW emp_view AS
SELECT Ename, Salary
FROM emp;

-- 7. PURPOSE: Verify inserted data and view
SELECT * FROM emp;
SELECT * FROM emp_view;
For immediate assistance, please email our customer support: support@toptal.com

